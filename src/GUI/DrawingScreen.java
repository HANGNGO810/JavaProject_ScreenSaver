/*
 *  Copyright (c) 2024. Lorem ipsum dolor sit amet, consectetur adipiscing elit.
 *  Morbi non lorem porttitor neque feugiat blandit. Ut vitae ipsum eget quam lacinia accumsan.
 *  Etiam sed turpis ac ipsum condimentum fringilla. Maecenas magna.
 *  Proin dapibus sapien vel ante. Aliquam erat volutpat. Pellentesque sagittis ligula eget metus.
 *  Vestibulum commodo. Ut rhoncus gravida arcu.
 */

package GUI;

import Classes.*;
import Classes.Rectangle;
import Classes.Shape;

import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;

import javax.swing.JPanel;
import javax.swing.Timer;

public class DrawingScreen extends JPanel {
    //Properties
    private ArrayList<Shape> shapeList = new ArrayList<Shape>();//Array to store different shapes are generated by mouse clicked
    private Timer timer = new Timer(20, new TimerAction());

    //Constructor
    public DrawingScreen() {
        /*LOGIC:
        * Timer is always on  --> call TimerAction() --> triggerTheMove() -->   checkCollision(currentShape) --> moveTheShape()
        * When the mouse is click --> generate a Random Shape, save to the ArrayList name shapeList
        * Programmed Rules: User can not click to generate shapes around the edge of the panels, ensure that the new shape is not half in and haft out of the panel
                          User can not click around the area that already have a shape
                          when the panel is RESIZED, the object does not move out of the panel
                          When collision happened: shapes will change the color and change direction
        * Applying Polymorphism
                          When collision happened --> if the Shape is Bowtie --> flip()
                                                      if the Shape is Flower --> blossom()
                                                      if the Shape is Circle-->  whiteningCircle()
       */

        //Turn the timer on
        timer.start();
        //Add mouse listener
        this.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                //Get the position of mouse click
                int mouseX = e.getX();
                int mouseY = e.getY();
                //Call the function to generate the random shape with the mouse clicked positions
                createRandomShape(mouseX, mouseY);
            }
        });
    }

    //TimerAction method
    private class TimerAction implements ActionListener {
        @Override
        public void actionPerformed(ActionEvent e) {
            //Call function to kick shapes moving
            if(shapeList!=null) {
                triggerTheMove();
            }
        }
    }

    //Method to trigger the move of all shapes: check collision --> move the shape --> repaint the shape after the loop is finished
    public void triggerTheMove() {
        for (Shape currentShape : shapeList) {
            //Check collision: if current shape hits the wall or hits other objects
            checkCollision(currentShape);
            //Let the shape move
            currentShape.moveTheShape(this.getWidth(), this.getHeight());
        }
        //repaint the shape
        this.repaint();
    }

    //Method to detect collision between shapes
    public void checkCollision(Shape currentShape) {

        //-----1. CHECK THE COLLISION BETWEEN OBJECTS-------------
        boolean isCollided = false;//variable stores status of the currentShape (collided or not collided)

        //Loop through the shapeList, get the neighborShape which is not the currentShape
        for (Shape neighborShape : shapeList) {
            if (neighborShape != currentShape) {
                //Call intersects() method from the Shape class to detect collision of the currentShape with each of the neighbor Shapes
                isCollided = currentShape.intersects(neighborShape.getPositionThisObject());
                if (isCollided)
                    break; //If collision is happened, break the loop
            }
        }
        //If collision is detected
        if (isCollided) {
            //Change direction of the shape
            currentShape.setxSpeed(currentShape.getxSpeed() * -1);
            currentShape.setySpeed(currentShape.getySpeed() * -1);

            //Change colors of the shape
            currentShape.setShapeColor(currentShape.createColor(currentShape.getShapeColor()));

            //Applying Polymorphism
            // Check if shape is a Bowtie --> flipBowtie()
            if(currentShape instanceof Bowtie){
                //Downcast currentShape to subClass Bowtie
                Bowtie currentBowtie = (Bowtie) currentShape;
                currentBowtie.flipBowtie(true);
            }
            //Check if shape is a Flower --> blossom()
            else if (currentShape instanceof FLower){
                //Downcast currentShape to subClass Flower
                FLower currentFlower = (FLower) currentShape;
                currentFlower.blossom();
            }
            //Check if shape is a Circle -->whiteningCircle()
            else if (currentShape instanceof Circle){
                //Downcast currentShape to subClass Circle
                Circle currentCircle = (Circle) currentShape;
                currentCircle.whiteningCircle();
            }

            //if collision happened, change status of variable collisionStatus in Shape class to true
            currentShape.setCollisionStatus(true);
        }
        else  //if collision is not detected, change status of variable collisionStatus in Shape class to false
            currentShape.setCollisionStatus(false);

        //-----2. CHECK IF THE OBJECT HIT THE WALL-------------
        //Test Wall hit horizontally
        if (currentShape.getxPos() + currentShape.getWidth() >= this.getWidth()) {
                //Change the direction of the shape
                currentShape.setxSpeed(currentShape.getxSpeed() * -1);
            }
            //if hit the edge --> reverse direction
        else if (currentShape.getxPos() <= 0) {
                currentShape.setxSpeed(currentShape.getxSpeed() * -1);
            }
        //Test Wall hit vertically
        if (currentShape.getyPos() + currentShape.getHeight() >= this.getHeight()) {
                //Change the direction of the shape
                currentShape.setySpeed(currentShape.getySpeed() * -1);
            }
            //if hit the edge --> reverse direction
        else if (currentShape.getyPos() <= 0) {
                currentShape.setySpeed(currentShape.getySpeed() * -1);
            }
        }

    //PaintComponent method
    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        //Draw all shapes in the arraylist
        for(Shape currentShape: shapeList){
            currentShape.drawAShape(g);
        }
    }
    //Method to draw a random shape at position of mouse clicked
    public void createRandomShape(int mouseX, int mouseY){

        /* Explanation : Before create a random shape, the program determines whether any of the shapes already present on the panel intersect
                        or collide with the shape being created at the location where the mouse was clicked
        */
        //Get the width and height of Panel
        int panelWidth = this.getWidth();
        int panelHeight = this.getHeight();

        int randomNum = (int) (Math.random()* 6); //Create a random number
        boolean testStatus = false; //true: collision , false: not collision

        //Get position of the shape at mouse click
        //Note: 60 is max-height and max-width of all shapes
        int [][] positionMouseClicked = new int [4][2];
        //Left-Top (x, y)
        positionMouseClicked[0][0]= mouseX;
        positionMouseClicked[0][1]= mouseY;
        //Left-bottom (x, y+h)
        positionMouseClicked[1][0]= mouseX;
        positionMouseClicked[1][1]= mouseY+60;
        // Right-Top (x+w, y)
        positionMouseClicked[2][0]= mouseX+60;
        positionMouseClicked[2][1]= mouseY;
        //Right-Bottom (x+w, y+h)
        positionMouseClicked[3][0]= mouseX+60;
        positionMouseClicked[3][1]= mouseY+60;

        //Check a collision between any of the existing shapes and the shape created at the mouse-clicked location
        //By calling the function intersects in parent class (Shape) to detect collision
        for(Shape shape : shapeList) {
            if(shape.intersects(positionMouseClicked))
            {
                testStatus =true; //change status of testStatus variable when detect a collision
                break;//Break the loop--> do not create a random shape at this mouse click
            }
        }
        //IF condition to ensure a new shape is created inside the pane & avoid to have 2 shapes at same position of mouse clicked
        if (mouseX > 0 && mouseX < (panelWidth - 60) && mouseY > 0 && mouseY < panelHeight - 60 && !testStatus) {
            //If all the conditions are met, the code enters a switch statement based on the value of randomNum between 0-5
            switch (randomNum) { //Depending on the value of randomNum, a different shape object is created and added to a list (shapeList)
                case 0:
                    Rectangle rectangle1 = new Rectangle(Color.yellow, 25, 20, mouseX, mouseY);
                    shapeList.add(rectangle1);
                    break;
                case 1:
                    Circle circle1 = new Circle(new Color(255, 22, 150), 20, 30, mouseX, mouseY);
                    shapeList.add(circle1);
                    break;
                case 2:
                    Bowtie bowtie2 = new Bowtie(Color.GREEN, 40, 18, mouseX, mouseY);
                    shapeList.add(bowtie2);
                    break;
                case 3:
                    Triangle triangle1 = new Triangle(Color.red, 40, 20, mouseX, mouseY);
                    shapeList.add(triangle1);
                    break;
                case 4:
                    FLower flower1 = new FLower(Color.blue, 30, 30, mouseX, mouseY);
                    shapeList.add(flower1);
                    break;
                case 5:
                    Diamond diamond1 = new Diamond(Color.orange, 30, 15, mouseX, mouseY);
                    shapeList.add(diamond1);
                    break;
            }
        }
    }

    //Getters/ Setters
    public ArrayList<Shape> getShapeList() {
        return shapeList;
    }
    public void setShapeList(ArrayList<Shape> shapeList) {
        this.shapeList = shapeList;
    }


}





